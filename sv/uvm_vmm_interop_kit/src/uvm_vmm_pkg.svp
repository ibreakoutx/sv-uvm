//------------------------------------------------------------------------------
// Copyright 2008 Mentor Graphics Corporation
// Copyright 2010 Synopsys Inc.
//
// All Rights Reserved Worldwide
// 
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.  You may obtain
// a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
// License for the specific language governing permissions and limitations
// under the License.
//------------------------------------------------------------------------------

`ifndef UVM_VMM_PKG_SV
`define UVM_VMM_PKG_SV

`define VMM_UVM_INTEROP
`define VMM_IN_PACKAGE

import uvm_pkg::*;

//------------------------------------------------------------------------------
//    Copyright 2008 Mentor Graphics Corporation
//    All Rights Reserved Worldwide
// 
//    Licensed under the Apache License, Version 2.0 (the "License"); you may
//    not use this file except in compliance with the License.  You may obtain
//    a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
//    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
//    License for the specific language governing permissions and limitations
//    under the License.
//------------------------------------------------------------------------------
`ifndef UVM_ON_TOP
  `ifndef VMM_ON_TOP
     "No UVM|VMM_ON_TOP... must define UVM_ON_TOP or VMM_ON_TOP"
  `endif
`endif
  
package avt_interop_pkg;
  import uvm_pkg::*;
  import vmm_std_lib::*;
  
// for UVM_ON_TOP
//
// -------------------------------------------------------------
//    Copyright 2004-2009 Synopsys, Inc.
//    All Rights Reserved Worldwide
//
//    Licensed under the Apache License, Version 2.0 (the
//    "License"); you may not use this file except in
//    compliance with the License.  You may obtain a copy of
//    the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in
//    writing, software distributed under the License is
//    distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
//    CONDITIONS OF ANY KIND, either express or implied.  See
//    the License for the specific language governing
//    permissions and limitations under the License.
// -------------------------------------------------------------
//


//
// Redirect VMM messages to UVM with the following mapping
//
//   VMM FATAL   --> UVM FATAL/NONE
//   VMM ERROR   --> UVM ERROR/LOW
//   VMM WARNING --> UVM WARNING/MEDIUM
//   default     --> UVM INFO/MEDIUM
//     TRACE_SEV             /HIGH
//     DEBUG_SEV             /FULL
//     VERBOSE_SEV           /DEBUG
//


class avt_uvm_vmm_log_fmt extends vmm_log_format;

`ifdef UVM_ON_TOP
   static local avt_uvm_vmm_log_fmt auto_register = new();
`endif

   local uvm_report_server svr;
   local uvm_report_object client;
   local vmm_log log;

   function new();
      uvm_report_global_server gs = new;
      this.svr    = gs.get_server();
      this.client = new("VMM->UVM Report Client");
      this.log    = new("VMM->UVM", "Redirector");
      void'(this.log.set_format(this));
      // Make sure all messages are issed on the UVM side
      this.client.set_report_verbosity_level(32'h7FFF_FFFF);
      // Let UVM abort after too many errors
      this.log.stop_after_n_errors(0);
   endfunction


   virtual function string format_msg(string name,
                                      string inst,
                                      string msg_typ,
                                      string severity,
`ifdef VMM_LOG_FORMAT_FILE_LINE
                                      string fname,
                                      int    line,
`endif
                                      ref string lines[$]);
`ifndef VMM_LOG_FORMAT_FILE_LINE
      string fname = "";
      int    line  = 0;
`endif
      uvm_severity uvm_sev;
      int uvm_verb;
      string msg;

      uvm_sev  = UVM_INFO;
      uvm_verb = UVM_MEDIUM;

      if (severity == this.log.sev_image(vmm_log::FATAL_SEV))
         uvm_verb = UVM_NONE;
      else if (severity == this.log.sev_image(vmm_log::ERROR_SEV))
         uvm_verb = UVM_LOW;
      else if (severity == this.log.sev_image(vmm_log::TRACE_SEV))
         uvm_verb = UVM_HIGH;
      else if (severity == this.log.sev_image(vmm_log::DEBUG_SEV))
         uvm_sev = UVM_FULL;
      else if (severity == this.log.sev_image(vmm_log::VERBOSE_SEV))
         uvm_sev = UVM_DEBUG;

      if (msg_typ == this.log.typ_image(vmm_log::FAILURE_TYP)) begin
         case (uvm_verb)
            UVM_NONE:   uvm_sev = UVM_FATAL;
            UVM_LOW:    uvm_sev = UVM_ERROR;
            UVM_MEDIUM: uvm_sev = UVM_WARNING;
         endcase
      end

      if (lines.size() > 0) begin
         int i = 1;
         msg = lines[0];
         while (i < lines.size()) begin
            msg = {msg, "\n", lines[i]};
         end
      end

      this.svr.report(uvm_sev, name, inst, msg, uvm_verb,
                      fname, line, this.client);

      return "";
   endfunction: format_msg
   

   virtual function string continue_msg(string name,
                                        string inst,
                                        string msg_typ,
                                        string severity,
`ifdef VMM_LOG_FORMAT_FILE_LINE
                                        string fname,
                                        int    line,
`endif
                                        ref string lines[$]);
      return this.format_msg(name, inst, msg_typ, severity,
`ifdef VMM_LOG_FORMAT_FILE_LINE
                             fname, line,
`endif
                             lines);
   endfunction: continue_msg
endclass
//------------------------------------------------------------------------------
// Copyright 2008 Mentor Graphics Corporation
// All Rights Reserved Worldwide
// 
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.  You may obtain
// a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
// License for the specific language governing permissions and limitations
// under the License.
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
//
// Title: Integrated Phase Control - UVM-on-top
//
//------------------------------------------------------------------------------
//
// This class is used to wrap a VMM env for use as an uvm_component in an
// UVM environment. The <avt_uvm_vmm_env> component provides default implementations
// of the UVM phases that delegate to the underlying VMM env's phases. 
// Any number of vmm_env's may be wrapped and reused using the <avt_uvm_vmm_env>.
//
// All other VMM components, such as the ~vmm_subenv~ and ~vmm_xactor~, do not
// require integrated phase support; they can be instantiated and initialized
// directly by the parent component using their respective APIs.
//
// Implementation:
//
// New phases are added to UVM's phasing lineup to accommodate VMM env phases
// that do not have a direct UVM mapping. These include ~vmm_gen_cfg~, which
// delegates to the VMM env's ~gen_cfg~ phase, and ~vmm_report~, which delegates
// to the ~report~ phase. (UVM's report phase is a function, whereas VMM's
// report phase is a task.) These extra phases are transparent to UVM
// components.
//
// With VMM_UVM_INTEROP defined, VMM env phasing is controlled by
// the <avt_uvm_vmm_env> as follows:
//
//|            UVM                  VMM (env)
//|             |                    
//|         vmm_gen_cfg ---------> gen_cfg
//|             |                    
//|           build     --------->  build
//|             |   
//|          connect
//|             |
//|     end_of_elaboration
//|             |
//|     start_of_simulation
//|             |
//|            run --------------> reset_dut
//|             |                  cfg_dut
//|             |                  start
//|             |                  wait_for_end
//|             |  stop
//|             |  request
//|             |   |
//|             |  stop----------> stop
//|             |   |              cleanup
//|             |   |
//|             X<--|   
//|             |    
//|             |
//|          extract
//|             |
//|           check
//|             |
//|           report 
//|             |
//|         vmm_report ----------> report
//|             |
//|             *
//
// Per the UVM use model, the user may customize <avt_uvm_vmm_env>'s default test
// flow by extending and overriding any or all of the UVM phase callbacks.
// You can add functionality before or after calling super.<phase>, or you
// can completely replace the default implementation by not calling super.
// The new <avt_uvm_vmm_env> subtype can then be selected on a type or
// instance basis via the ~uvm_factory~.
//
//------------------------------------------------------------------------------
`ifdef UVM_ON_TOP 
`uvm_phase_func_topdown_decl(vmm_gen_cfg)
`uvm_phase_task_bottomup_decl(vmm_report)

typedef class avt_uvm_vmm_env_base;

vmm_gen_cfg_phase #(avt_uvm_vmm_env_base) vmm_gen_cfg_ph = new;
vmm_report_phase  #(avt_uvm_vmm_env_base) vmm_report_ph = new;


//------------------------------------------------------------------------------
//
// CLASS: avt_uvm_vmm_env_base
//
//------------------------------------------------------------------------------
//
// The ~avt_uvm_vmm_env_base~ class is used to "wrap" an existing ~vmm_env~ subtype
// so that it may be reused as an ordinary UVM component in an UVM-on-top
// environment. If an instance handle to the ~vmm_env~ subtype is not provided
// in the constructor, a new instance will be created and placed in the ~env~
// public property.
//
// When UVM runs through its phasing lineup, the ~avt_uvm_vmm_env_base~ component
// delegates to the appropriate phase methods in the underlying ~env~ object.
// Thus, the VMM env phasing is sychronized with UVM phasing. Although the
// default mapping between UVM and VMM phases is deemed the best in most
// applications, users may choose to override the phase methods in a subtype
// to this class to implement a different phasing scheme.
//
//------------------------------------------------------------------------------

class avt_uvm_vmm_env_base extends uvm_component;

  `uvm_component_utils(avt_uvm_vmm_env_base)

  vmm_env env;

  local static bit m_phases_inserted = insert_vmm_phases();

  // Variable: ok_to_stop
  //
  // When ~ok_to_stop~ is clear (default), the avt_uvm_vmm_env's <stop> task will
  // wait for the VMM env's ~wait_for_end~ task to return before continuing.
  // This bit is automatically set with the underlying VMM env's ~wait_for_end~
  // task returns, which allows the <stop> <stop> task to call the VMM env's
  // ~stop~ and ~cleanup~ phases.
  // 
  // If ~ok_to_stop~ is set manually, other UVM components will be able to
  // terminate the run phase before the VMM env has returned from ~wait_for_end~.

  bit ok_to_stop = 0;


  // Variable: auto_stop_request
  //
  // When set, this bit enables calling an UVM stop_request after
  // the VMM env's wait_for_end task returns, thus ending UVM's run phase
  // coincident with VMM's wait_for_end. Default is 0.
  //
  // A wrapped VMM env is now a mere subcomponent of a larger-scale UVM
  // environment (that may incorporate multiple wrapped VMM envs).  A VMM envs'
  // end-of-test condition is no longer sufficient for determining the overall
  // end-of-test condition. Thus, the default value for ~auto_stop_request~
  // is 0. Parent components of the VMM env wrapper may choose to wait on the
  // posedge of <ok_to_stop> to indicate the VMM env has reached its end-of-test
  // condition.

  bit auto_stop_request = 0;


  // Function: new
  //
  // Creates the vmm_env proxy class with the given name, parent, and optional
  // vmm_env handle.  If the env handle is null, it is assumed that an extension
  // of this class will be responsible for creating and assigning the m_env
  // internal variable.
  
  function new (string name, uvm_component parent=null,
                vmm_env env=null);
  
    super.new(name,parent);

    if (vmm_report_ph == null) vmm_report_ph = new();
    uvm_top.insert_phase(vmm_report_ph, report_ph);

    this.env = env;

    enable_stop_interrupt = 1;

  endfunction
  
  
  // Function: insert_vmm_phases
  //
  // A static function that registers the ~vmm_gen_cfg~ phase callback with the UVM.
  // It is called as part of static initialization before any env or phasing
  // can begin. This allows the ~vmm_env~ to be created as an UVM component
  // in ~build~ phase.
  
  local static function bit insert_vmm_phases();
    if (vmm_gen_cfg_ph == null)
      vmm_gen_cfg_ph   = new;
    uvm_top.insert_phase(vmm_gen_cfg_ph, null);
    return 1;
  endfunction
   
  
  // Function: vmm_gen_cfg
  //
  // Calls the underlying VMM env's gen_cfg phase.
  
  virtual function void vmm_gen_cfg();
    if (this.env == null) begin
      uvm_report_fatal("NUVMMENV","The avt_uvm_vmm_env requires a vmm_env instance");
      return;
    end
    uvm_top.check_verbosity();
    env.gen_cfg();
  endfunction
  
  
  // Function: build
  //
  // Calls the underlying VMM env's build phase. Disables the underlying
  // env from manually calling into the UVM's phasing mechanism.
  
  virtual function void build();
    env.build();
  endfunction
  

  // Task: vmm_reset_dut
  //
  // Calls the underlying VMM env's reset_dut phase, provided this
  // phase was enabled in the <new> constructor.

  virtual task vmm_reset_dut();
    env.reset_dut();
    uvm_top.stop_request();
  endtask

  
  // Task: vmm_cfg_dut
  //
  // Calls the underlying VMM env's cfg_dut phase, provided this
  // phase was enabled in the <new> constructor.

  virtual task vmm_cfg_dut();
    env.cfg_dut();
    uvm_top.stop_request();
  endtask

  
  // Task: run
  //
  // Calls the underlying VMM env's reset_dut, cfg_dut, start, and
  // wait_for_end phases, returning when the env's end-of-test
  // condition has been reached. Extensions of this method may augment
  // or remove certain end-of-test conditions from the underlying env's
  // consensus object before calling ~super.run()~. When ~super.run()~
  // returns, extensions may choose to call ~uvm_top.stop_request()~ if
  // the underlying env is the only governor of end-of-test.
  // 
  // Extensions may completely override this base implementation by
  // not calling ~super.run()~. In such cases, all four VMM phases must
  // still be executed in the prescribed order.
  
  virtual task run();
    env.reset_dut();
    env.cfg_dut();
    env.start();
    env.wait_for_end();
    if (auto_stop_request)
      uvm_top.stop_request();
    ok_to_stop = 1;
  endtask
  
  
  // Task: stop
  //
  // If the ~run~ phase is being stopped, this task waits for the
  // underlying env's ~wait_for_end~ phase to return, then calls the
  // VMM env's stop and cleanup tasks. If the <ok_to_stop> variable
  // is set at the time ~stop~ is called, then ~stop~ will not wait
  // for ~wait_for_end~ to return. This allows UVM components to
  // control when the VMM env and its embedded xactors are stopped.
  
  virtual task stop(string ph_name); 
    if (ph_name == "run") begin
      if (!ok_to_stop)
        @ok_to_stop;
      env.stop();
      env.cleanup();
    end
  endtask
  

  // Task: vmm_report
  //
  // Calls the underlying VMM env's report method, then stops the
  // reportvmm phase. This phase is called after UVM's ~report~
  // phase has completed.
  
  virtual task vmm_report();
    env.report();
    uvm_top.stop_request();
    vmm_report_ph.wait_done();
  endtask

endclass


typedef class avt_vmm_uvm_env;

//------------------------------------------------------------------------------
//
// CLASS: avt_uvm_vmm_env
//
// Use this class to wrap (contain) an existing VMM env whose constructor does
// not have a ~name~ argument. See <avt_uvm_vmm_env_base> for more information.
//
//------------------------------------------------------------------------------

class avt_uvm_vmm_env #(type ENV=vmm_env) extends avt_uvm_vmm_env_base;

   typedef avt_uvm_vmm_env #(ENV) this_type;

  `uvm_component_utils(this_type)

  ENV env;

  // Function: new
  //
  // Creates a VMM env container component with the given ~name~ and ~parent~.
  // A new instance of an env of type ~ENV~ is created if one is not
  // provided in the ~env~ argument. The ~env~ will not be named.

  function new (string name,
                uvm_component parent=null,
                ENV env=null);
    avt_vmm_uvm_env avt_env;
    super.new(name,parent,env);
    if (env == null)
      env = new();
    if ($cast(avt_env,env))
      avt_env.disable_uvm = 1;
    this.env = env;
    super.env = env;
  endfunction

endclass


//------------------------------------------------------------------------------
//
// CLASS: avt_uvm_vmm_env_named
//
// Use this class to wrap (contain) an existing VMM env whose constructor
// must have a ~name~ argument. See <avt_uvm_vmm_env_base> for more information.
//
//------------------------------------------------------------------------------

class avt_uvm_vmm_env_named #(type ENV=vmm_env) extends avt_uvm_vmm_env_base;

   typedef avt_uvm_vmm_env_named #(ENV) this_type;

  `uvm_component_utils(this_type)

  ENV env;

  // Function: new
  //
  // Creates a VMM env container component with the given ~name~ and ~parent~.
  // A new instance of an env of type ~ENV~ is created if one is not
  // provided in the ~env~ argument. The name given the new ~env~ is
  // the full name of this component. 

  function new (string name,
                uvm_component parent=null,
                ENV env=null);
    avt_vmm_uvm_env avt_env;
    super.new(name,parent,env);
    if (env == null)
      env = new({parent==null?"":{parent.get_full_name(),"."},name});
    if ($cast(avt_env,env))
      avt_env.disable_uvm = 1;
    this.env = env;
    super.env = env;
  endfunction

endclass


`endif//------------------------------------------------------------------------------
// Copyright 2008 Mentor Graphics Corporation
// All Rights Reserved Worldwide
// 
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.  You may obtain
// a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
// License for the specific language governing permissions and limitations
// under the License.
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
//
// Title: Integrated Phase Control - UVM-on-top
//
//------------------------------------------------------------------------------
//
// This class is used to wrap a VMM timeline for use as an uvm_component in an
// UVM environment. The <avt_uvm_vmm_timeline> component provides default implementations
// of the UVM phases that delegate to the underlying VMM timeline's phases. 
// Any number of vmm_timeline's may be wrapped and reused using the <avt_uvm_vmm_timeline>.
//
// All other VMM components, such as the ~vmm_subenv~ and ~vmm_xactor~, do not
// require integrated phase support; they can be instantiated and initialized
// directly by the parent component using their respective APIs.
//
// Implementation:
//
// New phases are added to UVM's phasing lineup to accommodate VMM timeline phases
// that do not have a direct UVM mapping. These include ~vmm_rtl_config~, which
// delegates to the VMM timeline's ~rtl_config~ phase and ~vmm_cleanup~, as VMM ~cleanup_ph~ 
// is a task wheras ~check~ in UVM is a function. These extra phases are transparent to UVM
// components.
//
// With VMM_UVM_INTEROP defined, VMM timeline phasing is controlled by
// the <avt_uvm_vmm_timeline> as follows:
//
//|            UVM                  VMM (timeline)
//|             |                    
//|         vmm_rtl_config ---------> rtl_config
//|             |                    
//|           build     --------->  build
//|             |                   configure
//|             |   
//|          connect    --------->  connect
//|             |
//|     end_of_elaboration
//|             |
//|     start_of_simulation--------->  start_of_sim
//|             |
//|            run --------------> reset
//|             |                  training
//|             |                  config_dut
//|             |                  start
//|             |                  run
//|             |  stop
//|             |  request
//|             |   |
//|             |  stop----------> shutdown
//|             |   |              
//|             |   |
//|             X<--|   
//|             |    
//|             |
//|          extract
//|             |
//|           check
//|             |
//|          vmm_cleanup --------------> cleanup
//|             |
//|           report ----------> report
//|             |
//|             *
//
// Per the UVM use model, the user may customize <avt_uvm_vmm_timeline>'s default test
// flow by extending and overriding any or all of the UVM phase callbacks.
// You can add functionality before or after calling super.<phase>, or you
// can completely replace the default implementation by not calling super.
// The new <avt_uvm_vmm_timeline> subtype can then be selected on a type or
// instance basis via the ~uvm_factory~.
//
//------------------------------------------------------------------------------
`ifdef UVM_ON_TOP 
`uvm_phase_func_topdown_decl(vmm_rtl_config)
`uvm_phase_task_bottomup_decl(vmm_cleanup)

typedef class avt_uvm_vmm_timeline;
typedef class avt_vmm_uvm_timeline;

vmm_rtl_config_phase #(avt_uvm_vmm_timeline) vmm_rtl_config_ph = new;
vmm_cleanup_phase  #(avt_uvm_vmm_timeline) vmm_cleanup_ph = new;


//------------------------------------------------------------------------------
//
// CLASS: avt_uvm_vmm_timeline
//
//------------------------------------------------------------------------------
//
// The ~avt_uvm_vmm_timeline~ class is used to "wrap" an existing ~vmm_timeline~ subtype
// so that it may be reused as an ordinary UVM component in an UVM-on-top
// environment. If an instance handle to the ~vmm_timeline~ subtype is not provided
// in the constructor, a new instance will be created and placed in the ~timeline~
// public property.
//
// When UVM runs through its phasing lineup, the ~avt_uvm_vmm_timeline~ component
// delegates to the appropriate phase methods in the underlying ~timeline~ object.
// Thus, the VMM timeline phasing is sychronized with UVM phasing. Although the
// default mapping between UVM and VMM phases is deemed the best in most
// applications, users may choose to override the phase methods in a subtype
// to this class to implement a different phasing scheme.
//
//------------------------------------------------------------------------------

class avt_uvm_vmm_timeline extends uvm_component;

  `uvm_component_utils(avt_uvm_vmm_timeline)

  static vmm_timeline  timeline = new;

  local static bit m_phases_inserted = insert_vmm_phases();

  // Variable: ok_to_stop
  //
  // When ~ok_to_stop~ is clear (default), the avt_uvm_vmm_timeline's <stop> task will
  // wait for the VMM timeline's ~wait_for_end~ task to return before continuing.
  // This bit is automatically set with the underlying VMM timeline's ~wait_for_end~
  // task returns, which allows the <stop> <stop> task to call the VMM timeline's
  // ~stop~ and ~cleanup~ phases.
  // 
  // If ~ok_to_stop~ is set manually, other UVM components will be able to
  // terminate the run phase before the VMM timeline has returned from ~wait_for_end~.

  bit ok_to_stop = 0;


  // Variable: auto_stop_request
  //
  // When set, this bit enables calling an UVM stop_request after
  // the VMM timeline's wait_for_end task returns, thus ending UVM's run phase
  // coincident with VMM's wait_for_end. Default is 0.
  //
  // A wrapped VMM timeline is now a mere subcomponent of a larger-scale UVM
  // environment (that may incorporate multiple wrapped VMM timelines).  A VMM timelines'
  // end-of-test condition is no longer sufficient for determining the overall
  // end-of-test condition. Thus, the default value for ~auto_stop_request~
  // is 0. Parent components of the VMM timeline wrapper may choose to wait on the
  // posedge of <ok_to_stop> to indicate the VMM timeline has reached its end-of-test
  // condition.

  bit auto_stop_request = 0;


  // Function: new
  //
  // Creates the vmm_timeline proxy class with the given name, parent, and optional
  // vmm_timeline handle.  If the timeline handle is null, it is assumed that an extension
  // of this class will be responsible for creating and assigning the m_timeline
  // internal variable.

  function new (string name, uvm_component parent=null);   
     avt_vmm_uvm_timeline avt_timeline;
    super.new(name,parent);
     
     if (vmm_cleanup_ph == null) vmm_cleanup_ph = new();
     uvm_top.insert_phase(vmm_cleanup_ph, run_ph);
     
     enable_stop_interrupt = 1;
     
     if ($cast(avt_timeline,timeline)) avt_timeline.disable_uvm = 1;
  endfunction
 
  // Function: insert_vmm_phases
  //
  // A static function that registers the ~vmm_rtl_config~ phase callback with the UVM.
  // It is called as part of static initialization before any timeline or phasing
  // can begin. This allows the ~vmm_timeline~ to be created as an UVM component
  // in ~build~ phase.
  
  local static function bit insert_vmm_phases();
    if (vmm_rtl_config_ph == null)
      vmm_rtl_config_ph   = new;
    uvm_top.insert_phase(vmm_rtl_config_ph, null);
    return 1;
  endfunction
   
  
  // Function: vmm_rtl_config
  //
  // Calls the underlying VMM timeline's rtl_config phase.
  
  virtual function void vmm_rtl_config();
    if (this.timeline == null) begin
      uvm_report_fatal("NUVMMTIMELINE","The avt_uvm_vmm_timeline requires a vmm_timeline instance");
      return;
    end
    uvm_top.check_verbosity();  
   fork timeline.run_phase("rtl_config"); join_none
  endfunction
  
  
  // Function: build
  //
  // Calls the underlying VMM timeline's build phase. Disables the underlying
  // timeline from manually calling into the UVM's phasing mechanism.
  
  virtual function void build();
   fork timeline.run_phase("configure"); join_none
  endfunction
  
  // Function: connect
  //
  // Calls the underlying VMM timeline's connect phase. Disables the underlying
  // timeline from manually calling into the UVM's phasing mechanism.
  
  virtual function void connect();
  fork timeline.run_phase("connect"); join_none
  endfunction // void
   
  // Function: start_of_simulation
  //
  // Calls the underlying VMM timeline's start_of_sim phase. Disables the underlying
  // timeline from manually calling into the UVM's phasing mechanism.
  
  virtual function void start_of_simulation();
  fork timeline.run_phase("start_of_sim"); join_none
  endfunction // void
  
  
  // Task: run
  //
  // Calls the underlying VMM timeline's reset_dut, cfg_dut, start, and
  // wait_for_end phases, returning when the timeline's end-of-test
  // condition has been reached. Extensions of this method may augment
  // or remove certain end-of-test conditions from the underlying timeline's
  // consensus object before calling ~super.run()~. When ~super.run()~
  // returns, extensions may choose to call ~uvm_top.stop_request()~ if
  // the underlying timeline is the only governor of end-of-test.
  // 
  // Extensions may completely override this base implementation by
  // not calling ~super.run()~. In such cases, all VMM phases must
  // still be executed in the prescribed order.
  
  virtual task run();
   timeline.run_phase("run");
    if (auto_stop_request)
      uvm_top.stop_request();
    ok_to_stop = 1;
  endtask
  
  
  // Task: stop
  //
  // If the ~run~ phase is being stopped, this task waits for the
  // underlying timeline's ~wait_for_end~ phase to return, then calls the
  // VMM timeline's stop and cleanup tasks. If the <ok_to_stop> variable
  // is set at the time ~stop~ is called, then ~stop~ will not wait
  // for ~wait_for_end~ to return. This allows UVM components to
  // control when the VMM timeline and its embedded xactors are stopped.
  
  virtual task stop(string ph_name); 
    if (ph_name == "run") begin
      if (!ok_to_stop)
        @ok_to_stop;
      timeline.run_phase("shutdown");
    end
 endtask
  
   
  // Task: vmm_cleanup
  //
  // Calls the underlying VMM cleanup method, then stops the
  //  phase. This phase is called after UVM's ~check~
  // phase has completed.
  
  virtual task vmm_cleanup();
    timeline.run_phase("cleanup");
    uvm_top.stop_request();
    vmm_cleanup_ph.wait_done();
  endtask
   
  // Function: report
  //
  // Calls the underlying VMM timeline's report method, then stops the
  // reportvmm phase. This phase is called after UVM's ~report~
  // phase has completed.
  
  function void report();
     timeline.run_function_phase("report");
  endfunction // void


  
endclass // avt_uvm_vmm_timeline



`endif   
// for VMM_ON_TOP
//
//    Copyright 2009 Synopsys, Inc.
//    Copyright 2009 Mentor Graphics Corporation
//    All Rights Reserved Worldwide
//
//    Licensed under the Apache License, Version 2.0 (the
//    "License"); you may not use this file except in
//    compliance with the License.  You may obtain a copy of
//    the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in
//    writing, software distributed under the License is
//    distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
//    CONDITIONS OF ANY KIND, either express or implied.  See
//    the License for the specific language governing
//    permissions and limitations under the License.
//


//
// Redirect UVM messages to VMM with the following mapping
//
//   UVM FATAL   --> VMM FATAL
//   UVM ERROR   --> VMM ERROR
//   UVM WARNING --> VMM WARNING
//   UVM INFO    --> VMM NOTE  if verbosity level <= UVM_MEDIUM
//                   VMM DEBUG if verbosity level > UVM_MEDIUM
//

class avt_vmm_uvm_report_server extends uvm_report_server;

   `ifdef VMM_ON_TOP
   static local avt_vmm_uvm_report_server me = get();
   `endif

   `VMM_LOG log;

   local int vmm_sev;

   static function avt_vmm_uvm_report_server get();
     uvm_report_global_server gs = new;
     get = new;
     gs.set_server(get);
   endfunction

   `_protected function new();
      super.new();
      this.log = new("UVM", "reporter");
      // Make sure all UVM messages are issued by default
      this.log.set_verbosity(vmm_log::VERBOSE_SEV);
      // Let VMM abort if too many errors
      this.set_max_quit_count(0);
   endfunction
   

   virtual function void report(uvm_severity      severity,
                                string            name,
                                string            id,
                                string            message,
                                int               verbosity_level,
                                string            filename,
                                int               line,
                                uvm_report_object client);

           if (verbosity_level <= UVM_NONE)   this.vmm_sev = vmm_log::NORMAL_SEV;
      else if (verbosity_level <= UVM_LOW)    this.vmm_sev = vmm_log::NORMAL_SEV;
      else if (verbosity_level <= UVM_MEDIUM) this.vmm_sev = vmm_log::NORMAL_SEV;
      else if (verbosity_level <= UVM_HIGH)   this.vmm_sev = vmm_log::TRACE_SEV;
      else if (verbosity_level <= UVM_FULL)   this.vmm_sev = vmm_log::DEBUG_SEV;
      else                                    this.vmm_sev = vmm_log::VERBOSE_SEV;

      super.report(severity, name, id, message, verbosity_level,
                   filename, line, client);
   endfunction


   virtual function void process_report(uvm_severity      severity,
                                        string            name,
                                        string            id,
                                        string            message,
                                        uvm_action        action,
                                        UVM_FILE          file,
                                        string            filename,
                                        int               line,
                                        string            composed_message,
                                        int               verbosity_level,
                                        uvm_report_object client);
      int typ;
      case (severity)
        UVM_INFO:    typ = vmm_log::NOTE_TYP;
        UVM_WARNING: typ = vmm_log::FAILURE_TYP;
        UVM_ERROR:   typ = vmm_log::FAILURE_TYP;
        UVM_FATAL:   typ = vmm_log::FAILURE_TYP;
      endcase
      case (severity)
        UVM_WARNING: this.vmm_sev = vmm_log::WARNING_SEV;
        UVM_ERROR:   this.vmm_sev = vmm_log::ERROR_SEV;
        UVM_FATAL:   this.vmm_sev = vmm_log::FATAL_SEV;
      endcase

      if (this.log.start_msg(typ, this.vmm_sev `ifdef VMM_LOG_FORMAT_FILE_LINE , filename, line `endif )) begin
         void'(this.log.text(composed_message));
         this.log.end_msg();
      end
   endfunction


   virtual function string compose_message(uvm_severity severity,
                                           string       name,
                                           string       id,
                                           string       message,
                                           string       filename,
                                           int          line);
      // Severity, time, filename and line number
      // will be provided by vmm_log
      $sformat(compose_message, "%s(%s): %s",
               name, id, message);
   endfunction
endclass
//------------------------------------------------------------------------------
//    Copyright 2009 Mentor Graphics Corporation
//    Copyright 2009 Synopsys, Inc.
//    All Rights Reserved Worldwide
//
//    Licensed under the Apache License, Version 2.0 (the
//    "License"); you may not use this file except in
//    compliance with the License.  You may obtain a copy of
//    the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in
//    writing, software distributed under the License is
//    distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
//    CONDITIONS OF ANY KIND, either express or implied.  See
//    the License for the specific language governing
//    permissions and limitations under the License.
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
//
// Title: Integrated Phase Control - VMM-on-top
//
//------------------------------------------------------------------------------
//
// This class is used to ensure UVM components (i.e. all subtypes of
// uvm_component), when instantiated in VMM environments and/or components, have
// their phase methods called at the correct time relative to the execution of
// the top-level VMM environment phase methods.
//
// With VMM_UVM_INTEROP defined, UVM phasing is controlled by the ~avt_vmm_uvm_env~
// as follows:
//
//|             VMM                 UVM
//|             |                    
//|           gen_cfg                
//|             |                    
//|            build________________build
//|                   uvm_build       |
//|                                 connect
//|              _____________________/     
//|             |                      
//|             |_____________end_of_elaboration
//|                                   |
//|                           start_of_simulation
//|              _____________________/     
//|             |          
//|             |            
//|             |\__FORK run phase__ 
//|             |                    \
//|           reset_dut              run
//|             |                     |
//|           cfg_dut                 | 
//|             |                     |
//|           start                   |
//|             |                     |
//|        wait_for_end               |
//|             |                     |
//|             |_ stop  --> FORK     |
//|             | request        \    |
//|             |               stop  |
//|             |                 |   |    
//|             |                 |-->X    
//|             |__ WAIT -------> *
//|                 for run
//|              ___/  complete
//|           stop                   
//|             |                    
//|          cleanup                 
//|             |                    
//|             |
//|           report
//|             |___________________extract
//|                 uvm_report        |
//|                                  check
//|                                   |
//|                                 report 
//|                                   |
//|                                 <user>
//|                                   |
//|              _____________________*
//|             |
//|        <final report>
//|             |
//|             *
//
//------------------------------------------------------------------------------

`ifdef VMM_ON_TOP

// Replace the UVM message server with one that re-routes
// UVM messages to a vmm_log instance.

function bit avt_override_uvm_report_server();
  avt_vmm_uvm_report_server svr;
  uvm_report_global_server glob;
  svr = avt_vmm_uvm_report_server::get();
  glob = new();
  glob.set_server(svr);
  return 1;
endfunction

bit _avt_uvm_server = avt_override_uvm_report_server();

`endif

//------------------------------------------------------------------------------
//
// CLASS: avt_vmm_uvm_env
//
// This class is used to automatically integrate UVM phasing with VMM phasing
// in a VMM-on-top environment.
//------------------------------------------------------------------------------

class avt_vmm_uvm_env extends `AVT_VMM_UVM_ENV_BASE;

   bit disable_uvm = 0;
   protected int build_level;

   // Function: new
   // 
   // Creates a new instance of an ~avt_vmm_uvm_env~.

   function new(string name = "Verif Env"
                `VMM_ENV_BASE_NEW_EXTERN_ARGS);
     super.new(name
     `ifdef VMM_ENV_BASE_NEW_CALL
      `VMM_ENV_BASE_NEW_CALL
     `endif
     );

   endfunction


   // Function: uvm_build
   // 
   // Calls into the UVM's phasing mechanism to complete UVM's
   // ~build~, ~connect~, and any other user-defined phases
   // up to ~end_of_elaboration~.

   virtual function void uvm_build();
     if (disable_uvm)
       return;
     if (--build_level <= 0)
//       uvm_top.run_global_func_phase(configure_ph,1);
       uvm_top.run_global_func_phase(connect_ph,1);
   endfunction


   // Function: uvm_report
   // 
   // Calls into the UVM's phasing mechanism to complete UVM's
   // ~extract~, ~check~, and ~report~ phases.

   virtual task uvm_report();
     if (!disable_uvm) begin
       repeat(2) #0;
       uvm_top.run_global_phase(report_ph);
     end
   endtask


   // Task: reset_dut
   //
   // Syncs the start of VMM reset_dut with the start of UVM run phase,
   // then forks UVM run phase to run in parallel with reset_dut,
   // config_dut, start, and wait_for_end.

   virtual task reset_dut();
      if (this.step < BUILD)
        this.build();
      if (!disable_uvm) begin
        if (!connect_ph.is_done()) begin
         `vmm_fatal(this.log, {"The build() method did not call ",
                    "avt_vmm_uvm_env::uvm_build() before returning"});
        end
        uvm_top.run_global_phase(run_ph,1);
        fork
	   uvm_top.run_global_phase(run_ph);
        join_none
      end
      super.reset_dut();
   endtask


   // Function: stop
   // 
   // Requests the UVM run phase to stop if it is still running,
   // then waits for the UVM run phase to finish.

   virtual task stop();
      super.stop();
      if (!disable_uvm) begin
        if (!run_ph.is_done()) begin
           repeat (2) #0;
           global_stop_request();
           run_ph.wait_done();
        end
      end
   endtask


   // Task: report
   //
   // Calls into the UVM's phasing mechanism to execute user-defined
   // UVM phases inserted after ~report_ph~, if any.

   virtual task report();
      if (!disable_uvm) begin
        repeat (2) #0;
        uvm_top.run_global_phase();
      end
      super.report();
   endtask

endclass


// MACRO: `uvm_build
//
// Overrides the avt_vmm_uvm_env's <uvm_build> method such that the
// call to advance UVM phasing up to ~end_of_elaboration~ is
// performed only once in the most derived env-subtype of a
// a potentially deep vmm_env-inheritance hierarchy.

`define uvm_build \
   local int _uvm_build_level = ++build_level; \
   virtual function void uvm_build(); \
     if (disable_uvm) \
       return; \
     if (--build_level <= 0) \
       uvm_top.run_global_func_phase(connect_ph,1); \
   endfunction

// uvm_top.run_global_func_phase(configure_ph,1); 





  class avt_vmm_uvm_timeline extends vmm_timeline;
     `vmm_typename(avt_vmm_uvm_timeline)
       static avt_vmm_uvm_timeline avt_timeline=new();
     localparam RUN_IT = 0;
     localparam RUN_UPTO = 1;
     
   bit disable_uvm = 0;
   protected int build_level;
   local int 	 _uvm_build_level = ++build_level; 
     function new (string name="VMM_UVM timeline", vmm_object parent = null);
	super.new(name, name, parent);
     endfunction

     
     /* PRE_TEST_TIMELINE */
     function void rtl_config_ph();
     endfunction // void
    
     function void build_ph(); 
	if (!disable_uvm) begin 
	  if (--build_level <= 0) begin
	    uvm_top.run_global_func_phase(uvm_pkg::build_ph,RUN_IT);
	  end
	end 
     endfunction // void     
     
     function void configure_ph();
	if (!disable_uvm) begin
	   if (!uvm_pkg::build_ph.is_done()) begin
	      `vmm_fatal(this.log, {"The build_ph() method did not call ",
				    "avt_vmm_uvm_group::build_ph() before returning"});
           end
	end
     endfunction // void
     
     function void connect_ph();
	if (!disable_uvm) begin
	   if (!uvm_pkg::build_ph.is_done()) begin
	      `vmm_fatal(this.log, {"The build_ph() method did not call ",
				    "avt_vmm_uvm_group::build_ph() before returning"});
           end
	   uvm_top.run_global_func_phase(uvm_pkg::connect_ph,RUN_IT); 
	end
     endfunction

     /* TOP_TEST TIMLINE */
     
     function void configure_test_ph();
	if (!disable_uvm) begin
	   if (!uvm_pkg::connect_ph.is_done()) begin
              `vmm_fatal(this.log, {"The connect_ph() method did not call ",
				    "avt_vmm_uvm_group::connect() before returning"});
           end
	   //uvm_top.run_global_func_phase(uvm_pkg::configure_ph,RUN_IT); 
	   uvm_top.run_global_func_phase(uvm_pkg::end_of_elaboration_ph,RUN_IT);
	end
     endfunction

     function void start_of_sim_ph();
	if (!disable_uvm) begin 
	   if (!uvm_pkg::end_of_elaboration_ph.is_done()) begin
              `vmm_fatal(this.log, {"The configure_test_ph() method did not call ",
				    "avt_vmm_uvm_env::uvm_pkg::end_of_elaboration_ph() before returning"});
           end
	   uvm_top.run_global_func_phase(uvm_pkg::start_of_simulation_ph,RUN_IT);
	end 
     endfunction
     
     task reset_ph();
     	if (!disable_uvm) begin  
           if (!uvm_pkg::start_of_simulation_ph.is_done()) begin
              `vmm_fatal(this.log, {"The start_of_sim_ph() method did not call ",
				    "avt_vmm_uvm_env::uvm_pkg::start_of_simulation_ph() before returning"});
           end
           fork
           	uvm_top.run_global_phase(uvm_pkg::run_ph, RUN_IT);
           join_none
     	end
     endtask // reset_ph
     
     task training_ph();
     endtask
     task config_dut_ph();
     endtask
     task start_ph();
     endtask
     function void start_of_test_ph();
     endfunction     
     task run_ph(); 
     endtask
 
     // task: shutdown_ph
     //
     // Calls into the UVM's phasing mechanism 
     // to ensure completion of UVM ~run_ph~..     
     task shutdown_ph();
     	if (!disable_uvm) begin 
           if (!uvm_pkg::run_ph.is_done()) begin
              repeat (2) #0;
             global_stop_request();
              uvm_pkg::run_ph.wait_done();
           end	
     	end 
     endtask // shutdown
 
     // task: cleanup_ph
     //
     // Calls into the UVM's phasing mechanism to execute all
     // UVM phases after ~run_ph~, such as ~extract_ph~.    
     task cleanup_ph();
     	if (!disable_uvm) begin 
     		if (!uvm_pkg::run_ph.is_done()) begin
              `vmm_fatal(this.log, {"The shutdown_ph() method did not call ",
				    "uvm_top.gloabl_stop_request() "});
     		end	   repeat(2) #0;
//	   uvm_top.run_global_phase(uvm_pkg::extract_ph,RUN_IT); 
	   	uvm_top.run_global_phase(uvm_pkg::check_ph,RUN_IT); 
     	end 
     endtask // cleanup_ph
 
     // function: report_ph
     //
     // Calls into the UVM's phasing mechanism to execute UVM ~report_ph~.     
     function void report_ph();
     	if (!disable_uvm) begin 
           if (!uvm_pkg::check_ph.is_done()) begin
	      `vmm_fatal(this.log, {"The claenup_ph() method did not call ",
				    "avt_vmm_uvm_env::uvm_pkg::check_ph() before returning"});
	      end
	      uvm_top.run_global_func_phase(uvm_pkg::report_ph,RUN_IT);
     	end
     endfunction // void
     
     /* POST_TEST_TIMELINE */
     
     // function: final_ph
     //
     // Calls into the UVM's phasing mechanism to execute user-defined
     // UVM phases inserted after ~report_ph~, if any.
     function void final_ph();
     	if (!disable_uvm) begin
     		uvm_top.run_global_func_phase();
     	end
     endfunction
     
  endclass   
//------------------------------------------------------------------------------
//    Copyright 2008 Mentor Graphics Corporation
//    All Rights Reserved Worldwide
// 
//    Licensed under the Apache License, Version 2.0 (the "License"); you may
//    not use this file except in compliance with the License.  You may obtain
//    a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
//    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
//    License for the specific language governing permissions and limitations
//    under the License.
//------------------------------------------------------------------------------

`ifndef AVT_CONVERTER_SV
`define AVT_CONVERTER_SV

//------------------------------------------------------------------------------
//
// CLASS: avt_converter #(IN,OUT)
//
// This converter is a non-functional placeholder used as a default parameter
// value for any adapters' unused converters. 
//------------------------------------------------------------------------------

class avt_converter #(type IN=int, OUT=int);

  // Parameter: IN
  //
  // The input type to convert from.
  
  // Parameter: OUT
  //
  // The output type to convert to.

  // Function: convert
  //
  // Normally implemented to convert ~IN~ transactions to ~OUT~ transactions,
  // the ~convert~ function in this class does nothing. Thus, this class is
  // a dummy-converter used in adapter's default type parameter assignments.
  //
  // The ~to~ argument allows the conversion to copy into an existing
  // object and avoid the expense of allocation.
  // If ~to~ is null (default), the convert method should create a new
  // instance of OUT, copy the fields of ~in~ to it, and return it. If the
  // ~to~ argument is non-null, the convert method should copy the fields
  // of ~in~ to the corresponding fields of ~to~, then return ~to~.

  static function OUT convert(IN in, OUT to=null);  
    return to;
  endfunction

endclass

`endif // AVT_CONVERTER_SV

//------------------------------------------------------------------------------
//    Copyright 2008 Mentor Graphics Corporation
//    Copyright 2009 Synopsys, Inc.
//    All Rights Reserved Worldwide
// 
//    Licensed under the Apache License, Version 2.0 (the "License"); you may
//    not use this file except in compliance with the License.  You may obtain
//    a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
//    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
//    License for the specific language governing permissions and limitations
//    under the License.
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
//
// CLASS: avt_uvm_tlm2channel
//
//------------------------------------------------------------------------------
//
// Use this class to connect an UVM sequencer to a VMM driver via vmm_channel.
// Drivers can implement many different response-delivery models:
//
// - does not return a response
//
// - embeds a response in the original request transaction, which is available
//   to a requester that holds a handle to the original request.
//
// - returns a response in a separate vmm_channel
//
// The adapter can accommodate all such drivers.
//
//   (see avt_uvm_tlm2channel.gif)
//
// Communication is established by connecting the adapter to any of the above
// UVM producer types using the appropriate ports and exports.
//
// To use this adapter, the integrator instantiates an UVM producer, a VMM
// consumer, and an ~avt_uvm_tlm2channel~ adapter whose parameter values correspond
// to the UVM and VMM data types used by the producer and consumer and the
// converter types used to translate in one or both directions.
//
// If the default vmm_channels created by the VMM consumer or adapter are not
// used, then the integrator must also instantiate a request vmm_channel and a
// response vmm_channel, if the VMM consumer uses one.
//
// Integrators of VMM-on-top environments need to instantiate the UVM consumer
// and adapter via an UVM container, or wrapper component. This wrapper
// component serves to provide the connect method needed to bind the UVM ports
// and exports.
//
// See also <avt_uvm_tlm2channel example> and <avt_uvm_tlm2channel seq_item example>.
//
//------------------------------------------------------------------------------

class avt_uvm_tlm2channel #(type UVM_REQ     = int,
                             VMM_REQ     = int,
                             UVM2VMM_REQ = int,
                             VMM_RSP     = VMM_REQ,
                             UVM_RSP     = UVM_REQ,
                             VMM2UVM_RSP = avt_converter #(VMM_RSP,UVM_RSP))
                                              extends uvm_component;

   typedef avt_uvm_tlm2channel #(UVM_REQ, VMM_REQ, UVM2VMM_REQ,
                             VMM_RSP, UVM_RSP, VMM2UVM_RSP)
                              this_type;

   `uvm_component_param_utils(this_type)


   // Port: seq_item_port
   //
   // This bidirectional port is used to connect to an ~uvm_sequencer~ or any
   // other component providing an ~uvm_seq_item_export~. The uvm_seq_item port
   // and export communicate using the interface, <sqr_if_base #(REQ,RSP)>,
   // which, in part, defines the following methods:
   //
   //|  virtual task get  (output REQ request);
   //|  virtual task peek (output REQ request);
   //|  virtual task put  (RSP response);
   //
   // See <sqr_if_base #(REQ,RSP)> for information about this interface.

   uvm_seq_item_pull_port #(UVM_REQ,UVM_RSP) seq_item_port;


   // Port: put_export
   //
   // This export is used to receive transactions from an UVM producer
   // that utilizes a blocking or non-blocking put interface.
   uvm_put_imp #(UVM_REQ,this_type) put_export;


   // Port: master_export
   //
   // This bidirectional export is used to receive requests from and deliver
   // responses to an UVM producer that utilizes a blocking or non-blocking
   // master interface.
   uvm_master_imp #(UVM_REQ,UVM_RSP,this_type) master_export;


   // Port: blocking_transport_export
   //
   // This bidirectional export is used to receive requests from and deliver
   // responses to an UVM producer that utilizes a blocking transport interface.
   uvm_blocking_transport_imp #(UVM_REQ,UVM_RSP,this_type) blocking_transport_export;


   // Port: blocking_get_peek_port
   //
   // This unidirectional port is used to retrieve responses from a passive
   // UVM producer with a blocking get_peek export.
   uvm_blocking_get_peek_port #(UVM_REQ) blocking_get_peek_port;


   task blocking_get_peek_process();
   endtask


   // Port: blocking_put_port
   //
   // This port is used to deliver responses to an UVM producer that
   // expects responses from a blocking put interface.
   uvm_blocking_put_port #(UVM_REQ) blocking_put_port;



   // Port: blocking_slave_port
   //
   // This bidirectional port is used to request transactions from and deliver
   // responses to a passive UVM producer utilizing a blocking slave interface.
   uvm_blocking_slave_port #(UVM_REQ,UVM_RSP) blocking_slave_port;


   // Port: request_ap
   //
   // All transaction requests received from any of the interface ports and
   // exports in this adapter are broadcast out this analysis port to any UVM
   // subscribers. 
   uvm_analysis_port #(UVM_REQ) request_ap;


   // Port: response_ap
   //
   // All transaction responses received from any of the interface ports and
   // exports in this adapter are broadcast out this analysis port to any UVM
   // subscribers.  UVM producers that expect responses from an analysis
   // export may be connected to this port.
   uvm_analysis_port #(UVM_RSP) response_ap;


   // Function: new
   //
   // Creates a new avt_uvm_tlm2channel adapter given four optional arguments.
   //
   // name     - specifies the instance name. Default is "avt_uvm_tlm2channel".
   //
   // parent   - specfies the parent uvm_component, if any. When null, the
   //            parent becomes the implicit uvm_top.
   //
   // req_chan - the request vmm_channel instance. If not specified, it must be
   //            assigned directory to the <req_chan> variable before
   //            end_of_elaboration.
   //
   // req_chan - the request vmm_channel instance. If not specified, it must be
   //            assigned directory to the <req_chan> variable before
   //            end_of_elaboration.

   function new (string name="avt_uvm_tlm2channel",
                 uvm_component parent=null,
                 vmm_channel_typed #(VMM_REQ) req_chan=null,
                 vmm_channel_typed #(VMM_RSP) rsp_chan=null,
                 bit wait_for_req_ended=0);
      super.new(name,parent);

      // adapter may be driven by UVM producer via any of these exports
      put_export                = new("put_export",this);
      master_export             = new("master_export",this);
      blocking_transport_export = new("blocking_transport_export",this);

      // adapter may drive the UVM producer via any of these ports.
      seq_item_port             = new("seq_item_port",this,0);
      blocking_get_peek_port    = new("blocking_get_peek_port",this,0);
      blocking_put_port         = new("blocking_put_port",this,0);
      blocking_slave_port       = new("blocking_slave_port",this,0);
      request_ap                = new("request_ap",this);
      response_ap               = new("response_ap",this);

      if (req_chan == null)
        req_chan = new("TLM-to-Channel Adapter Request Channel",name);
      if (rsp_chan == null)
        rsp_chan = new("TLM-to-Channel Adapter Response Channel",name);
      this.req_chan = req_chan;
      this.rsp_chan = rsp_chan;
      this.wait_for_req_ended = wait_for_req_ended;
   endfunction


   // Function: build
   //
   // Called as part of a predefined test flow, this function will retrieve
   // the configuration setting for the <wait_for_req_ended> flag.

   virtual function void build();
     void'(get_config_int("wait_for_req_ended",this.wait_for_req_ended));
   endfunction


   // Function: end_of_elaboration
   //
   // Called as part of a predefined test flow, this function will check that
   // this component's <req_chan> variable has been configured with a non-null
   // instance of a vmm_channel #(VMM).

   virtual function void end_of_elaboration();
     if (this.req_chan == null)
       `uvm_fatal("Connection Error",
          "vmm_uvm_tlm2channel adapter requires a request vmm_channel");
   endfunction


   const static string type_name = "vmm_uvm_tlm2channel";


   // Function: get_type_name
   //
   // Returns the type name, i.e. "vmm_uvm_tlm2channel", of this
   // adapter.

   virtual function string get_type_name();
     return type_name;
   endfunction


   // Task: run
   //
   // Called as part of a predefined test flow, the run task forks a
   // process for getting requests from the <seq_item_port> and sending
   // them to the <req_chan> vmm_channel. If configured, it will also fork
   // an independent process for getting responses from the separate <rsp_chan>
   // vmm_channel and putting them back out the <seq_item_port>.

   virtual task run();

     bit port_is_connected = 0;

     if (this.seq_item_port.size()) begin
       //this.producer_port = seq_item_port;
       this.is_seq_item_port = 1;
       this.is_bidir_port = 1;
       port_is_connected = 1;
     end
     else if (blocking_get_peek_port.size()) begin
       this.producer_port = blocking_get_peek_port;
       port_is_connected = 1;
     end
     else if (blocking_slave_port.size()) begin
       this.producer_port = blocking_slave_port;
       this.is_bidir_port = 1;
       port_is_connected = 1;
     end

     if (port_is_connected) begin
       fork
         this.get_requests();
       join_none

       if (!this.is_bidir_port && !this.blocking_put_port.size() == 0 &&
           this.response_ap.size() == 0)
         this.rsp_chan.sink();
       else
         fork
           this.put_responses();
         join_none
     end

   endtask


   // Task: wait_for_ended
   //
   // Used to support VMM non-blocking completion models that indicate
   // and return response status via each transaction's ENDED notification.
   // For each transaction outstanding, this task is forked to wait for
   // the ENDED status. When that happens, the response is converted
   // and sent into the <rsp_chan>.
   //
   // The <wait_for_req_ended> bit, set in the constructor, determines
   // whether this task is used.

   virtual task wait_for_ended(VMM_REQ v_req);
     string data_id,scen_id;
     VMM_RSP v_rsp;
     assert($cast(v_rsp,v_req));
     fork
       begin : wait_for_ended_process
         v_req.notify.wait_for(vmm_data::ENDED);
         this.rsp_chan.sneak(v_rsp);
       end
       begin
         #this.request_timeout;
         data_id.itoa(v_req.data_id);
         scen_id.itoa(v_req.scenario_id);
         uvm_report_warning("Request Timed Out",
           {"The request with data_id=",data_id,
            " and scenario_id=",scen_id," timeout out."});
         disable wait_for_ended_process;
       end
     join
   endtask


   // Task: get_requests
   //
   // This task continually gets request transactions from the connected
   // sequencer, converts them to an equivalent VMM transaction, and puts
   // to the underlying <req_chan> vmm_channel.
   // 
   // If <wait_for_req_ended> is set and the <req_chan>'s full-level is 1, and
   // no <rsp_chan> is being used, it is assumed the put to <req_chan>
   // will not return until the transaction has been executed and the
   // response contained within the original request descriptor. In
   // this case, the modified VMM request is converted back to the
   // original UVM request object, which is then sent as a response to
   // both the <seq_item_port> and <response_ap> ports.
   //
   // This task is forked as a process from the <run> task.

   virtual task get_requests();
     UVM_REQ o_req;
     forever begin
       if (this.is_seq_item_port) begin
         seq_item_port.peek(o_req);
         this.put(o_req);
         seq_item_port.get(o_req); // pop
       end
       else begin
         producer_port.peek(o_req);
         this.put(o_req);
         producer_port.get(o_req); // pop
       end
     end
   endtask


   // Task: put_responses
   //
   // This task handles getting responses from the <rsp_chan> vmm_channel and
   // putting them to the appropriate UVM response port. The converters will handle
   // the transfer of (data_id,scenario_id) to (transaction_id/sequence_id)
   // information so responses can be matched to their originating requests.
   //
   // This task is forked as a process from the <run> task.

   virtual task put_responses();

     VMM_RSP v_rsp;
     UVM_RSP o_rsp;

     assert(this.rsp_chan != null);

     forever begin
       this.rsp_chan.get(v_rsp);
       o_rsp = VMM2UVM_RSP::convert(v_rsp);
       if (this.is_bidir_port) begin
         if (this.is_seq_item_port)
           this.seq_item_port.put(o_rsp);
	 else
           this.producer_port.put(o_rsp);
       end
       else if (blocking_put_port.size())
         this.blocking_put_port.put(o_rsp);
       this.response_ap.write(o_rsp);
     end

   endtask


   // Task: put
   //
   // Converts an UVM request to a VMM request and puts it into the
   // <req_chan> vmm_channel. Upon return, if <wait_for_req_ended> is set, the
   // VMM request is put to the <rsp_chan> for response-path processing.
   // The original UVM request is also written to the <request_ap>
   // analysis port.

   virtual task put (UVM_REQ o_req);
     VMM_REQ v_req;
     VMM_RSP v_rsp;
     v_req = UVM2VMM_REQ::convert(o_req);
     req_chan.put(v_req);
     request_ap.write(o_req);
     if (this.wait_for_req_ended)
       this.wait_for_ended(v_req);
     else begin
       assert($cast(v_rsp,v_req));
       this.rsp_chan.sneak(v_rsp);
     end
   endtask

 
   // Function: can_put
   //
   // Returns 1 if the <req_chan> can accept a new request.

   virtual function bit can_put ();
     return !this.req_chan.is_full();
   endfunction

 
   // Function: try_put
   //
   // If the <req_chan> can accept new requests, converts ~o_req~ to
   // its VMM equivalent, injects it into the channel, and returns 1.
   // Otherwise, returns 0.
   virtual function bit try_put (UVM_REQ o_req);
     VMM_REQ v_req;
     if (!this.can_put())
       return 0;
     v_req = UVM2VMM_REQ::convert(o_req);
     req_chan.sneak(v_req);
     request_ap.write(o_req);
     if (this.wait_for_req_ended)
       fork
       this.wait_for_ended(v_req);
       join_none
     else
     return 1;
   endfunction


   // Task: get
   //
   // Gets a response from the <rsp_chan>, converts, and returns in
   // the ~o_rsp~ output argument.

   virtual task get(output UVM_RSP o_rsp);
     VMM_RSP v_rsp;
     this.rsp_chan.get(v_rsp);
     o_rsp = VMM2UVM_RSP::convert(v_rsp);
   endtask

   // Function: can_get
   //
   // Returns 1 if a response is available to get, 0 otherwise.

   virtual function bit can_get();
     return !(this.rsp_chan.size() <= this.rsp_chan.empty_level() ||
              this.rsp_chan.is_locked(vmm_channel::SINK));
   endfunction
  

   // Function: try_get
   //
   // If a response is available in the <rsp_chan>, gets and returns
   // the response in the ~o_rsp~ output argument and returns 1.
   // Returns 0 otherwise.
   virtual function bit try_get(output UVM_RSP o_rsp);
     vmm_data v_base;
     VMM_RSP v_rsp;
     if (!this.can_get())
       return 0;
     rsp_chan.XgetX(v_base);
     assert($cast(v_rsp, v_base));
     o_rsp = VMM2UVM_RSP::convert(v_rsp);
     return 1;
   endfunction


   // Task: peek
   //
   // Peeks (does not consume) and converts a response from the <rsp_chan>.

   virtual task peek(output UVM_RSP o_rsp);
     VMM_RSP v_rsp;
     this.rsp_chan.get(v_rsp);
     o_rsp = VMM2UVM_RSP::convert(v_rsp);
   endtask


   // Function: can_peek
   //
   // Returns 1 if a transaction is available in the <rsp_chan>, 0 otherwise.

   virtual function bit can_peek();
     return this.can_get();
   endfunction


   // Function: try_peek
   //
   // If a response is available to peek from the <rsp_chan>, this function
   // peeks (does not consume) the transaction from the channel, converts,
   // and returns via the ~o_req~ output argument. Otherwise, returns 0.

   virtual function bit try_peek(output UVM_RSP o_rsp);
     vmm_data v_base;
     VMM_RSP v_rsp;
     if (!this.can_peek())
       return 0;
     v_base = rsp_chan.try_peek();
     assert($cast(v_rsp, v_base));
     o_rsp = VMM2UVM_RSP::convert(v_rsp);
     return 1;
   endfunction


  // Task: transport
  //
  // Blocking transport is used to atomically execute the geiven
  // request transaction, ~req~, and return the response in ~rsp~.

  task transport (UVM_REQ o_req, output UVM_RSP o_rsp);
    this.put(o_req);
    this.get(o_rsp);
  endtask



   // Variable: req_chan
   //
   // Handle to the request vmm_channel #(VMM) instance being adapted. 

   vmm_channel_typed #(VMM_REQ) req_chan;


   // Variable: rsp_chan
   //
   // Handle to the response vmm_channel #(VMM) instance being adapted.
   // The adapter uses a response channel regardless of whether the
   // VMM consumer uses it directly. This keeps the request and response
   // paths on the TLM side separate.

   vmm_channel_typed #(VMM_RSP) rsp_chan;


   // Variable: wait_for_req_ended
   //
   // When the VMM consumer does not use a separate response channel, this
   // bit specifies whether the response, which is annotated into the
   // original request, is available after a ~get~ from the request
   // channel (~wait_for_req_ended=0~) or after the original request's
   // ENDED status is indicated (~wait_for_req_ended=1~). The latter case
   // enables interconnecting with pipelined VMM consumers at the cost
   // of two additional processes for each outstanding request transaction.
   //
   // This variable can be specified in a <new> constructor argument, or set
   // via a set_config_int("wait_for_req_ended",value) call targeting this
   // component.

   protected bit wait_for_req_ended = 0;

   protected uvm_port_base #(uvm_tlm_if_base #(UVM_REQ,UVM_RSP)) producer_port;

   protected bit is_seq_item_port = 0;

   protected bit is_bidir_port = 0;

   time request_timeout = 100us;

endclass

//------------------------------------------------------------------------------
//    Copyright 2008 Mentor Graphics Corporation
//    Copyright 2009 Synopsys, Inc.
//    All Rights Reserved Worldwide
// 
//    Licensed under the Apache License, Version 2.0 (the "License"); you may
//    not use this file except in compliance with the License.  You may obtain
//    a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
//    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
//    License for the specific language governing permissions and limitations
//    under the License.
//------------------------------------------------------------------------------

class avt_match_uvm_id;

  static function bit match(uvm_sequence_item req,
                          uvm_sequence_item rsp);
     return req.get_sequence_id() == rsp.get_sequence_id() &&
            req.get_transaction_id() == rsp.get_transaction_id();
  endfunction

endclass

//------------------------------------------------------------------------------
//
// CLASS: avt_channel2uvm_tlm
//
//------------------------------------------------------------------------------
//
// Use this class to connect a VMM producer to an UVM consumer.
// Consumers can implement many different response-delivery models:
//
// - does not return a response
//
// - returns a response via a separate TLM port
//
// - embeds a response in the original request transaction, which is available
//   to a requester that holds a handle to the original request.
//
// The adapter can accommodate these consumer types.
//
//   (see avt_channel2uvm_tlm.gif)
//
// To use this adapter, the integrator instantiates a VMM producer, an UVM
// consumer, and an <avt_channel2uvm_tlm> adapter whose parameter values correspond
// to the VMM and UVM data types used by the producer and consumer and the
// converter types used to translate in one or both directions.
//
// If the default vmm_channels created by the VMM producer or adapter are not
// used, then the integrator must also instantiate a request vmm_channel and
// possibly a response vmm_channel, if the VMM producer uses one.
//
// Integrators of VMM-on-top environments need to instantiate the UVM consumer
// and adapter via an UVM container, or wrapper component. This wrapper
// component serves to provide the connect method needed to bind the UVM ports
// and exports.
//
// See also <avt_channel2uvm_tlm example> and <avt_channel2uvm_tlm seq_item example>.
//
//------------------------------------------------------------------------------

class avt_channel2uvm_tlm #(type VMM_REQ     = int,
                             UVM_REQ     = int,
                             VMM2UVM_REQ = int,
                             UVM_RSP     = UVM_REQ,
                             VMM_RSP     = VMM_REQ,
                             UVM2VMM_RSP = avt_converter #(UVM_RSP,VMM_RSP),
                             UVM_MATCH_REQ_RSP=avt_match_uvm_id)
                                              extends uvm_component;

   typedef avt_channel2uvm_tlm #(VMM_REQ, UVM_REQ, VMM2UVM_REQ,
                             UVM_RSP, VMM_RSP, UVM2VMM_RSP,
                             UVM_MATCH_REQ_RSP) this_type;

   `uvm_component_param_utils(this_type)


   // Port: seq_item_export
   //
   // Used by UVM driver consumers using the sequencer interface to
   // process transactions.  See <sqr_if_base #(REQ,RSP)> for information about
   // this interface.
   uvm_seq_item_pull_imp #(UVM_REQ, UVM_RSP, this_type) seq_item_export;

   // Port: get_peek_export
   //
   // For UVM consumers getting requests via peek/get
   uvm_get_peek_imp #(UVM_REQ, this_type) get_peek_export;

   // Port: response_export
   //
   // For UVM consumers returning responses via analysis write
   uvm_analysis_imp #(UVM_RSP, this_type) response_export;

   // Port: put_export
   //
   // For UVM consumers returning responses via blocking put
   uvm_put_imp #(UVM_RSP, this_type) put_export;

   // Port: slave_export
   //
   // For sending requests to passive UVM consumers via blocking put
   uvm_slave_imp #(UVM_REQ, UVM_RSP, this_type) slave_export;

   // Port: blocking_put_port
   //
   // For sending requests to ~passive~ UVM consumers via blocking put
   uvm_blocking_put_port #(UVM_RSP) blocking_put_port;

   // Port: blocking_transport_port
   //
   // For atomic execution with ~passive~ UVM consumers via blocking transport
   uvm_blocking_transport_port #(UVM_REQ, UVM_RSP) blocking_transport_port;


   // Port: blocking_master_port
   //
   // For driving a passive UVM consumers via blocking master interface
    uvm_blocking_master_port #(UVM_REQ, UVM_RSP) blocking_master_port;


   // Port: request_ap
   //
   // All requests are broadcast out this analysis port after successful
   // extraction from the request vmm_channel.
   uvm_analysis_port #(UVM_REQ) request_ap;


   // Port: response_ap
   //
   // All responses sent to the response channel are broadcast out this
   // analysis port.
   uvm_analysis_port #(UVM_RSP) response_ap;


   // Function: new
   //
   // Creates an instance of a avt_channel2uvm_tlm adaptor, with four optional
   // arguments.
   //
   // name     - specifies the instance name. Default is "avt_channel2uvm_tlm".
   //
   // parent   - specfies the parent uvm_component, if any. When null, the
   //            parent becomes the implicit uvm_top.
   //
   // req_chan - the request vmm_channel instance. If not specified, it must be
   //            assigned directory to the <req_chan> variable before
   //            end_of_elaboration.
   //
   // req_chan - the request vmm_channel instance. If not specified, it must be
   //            assigned directory to the <req_chan> variable before
   //            end_of_elaboration.

   function new (string name="avt_channel2uvm_tlm",
                 uvm_component parent=null,
                 vmm_channel_typed #(VMM_REQ) req_chan=null,
                 vmm_channel_typed #(VMM_RSP) rsp_chan=null,
                 bit rsp_is_req=1,
                 int unsigned max_pending_req=100);
      super.new(name,parent);
      // For active UVM producers
      seq_item_export = new("seq_item_export",this);
      get_peek_export = new("get_peek_export",this);
      response_export = new("response_export",this);
      put_export      = new("put_export",this);
      slave_export    = new("slave_export",this);

      // For passive UVM producers
      blocking_put_port       = new("blocking_put_port",this,0);
      blocking_transport_port = new("blocking_transport_port",this,0);
      blocking_master_port    = new("blocking_master_port",this,0);

      request_ap    = new("request_ap",this);
      response_ap   = new("response_ap",this);

      if (req_chan == null)
        req_chan = new("Channel-to-TLM Adapter Out Channel",name);
      this.req_chan = req_chan;
      this.rsp_chan = rsp_chan;
      this.rsp_is_req = rsp_is_req;
      this.max_pending_req = max_pending_req;
   endfunction


   // Function: build
   //
   // Called as part of a predefined test flow, this function will retrieve
   // the configuration setting for the <rsp_is_req> that
   // this component's <req_chan> variable has been configured with a non-null

   virtual function void build();
     void'(get_config_int("rsp_is_req",this.rsp_is_req));
     void'(get_config_int("pound_zero_count",this.pound_zero_count));
   endfunction


   // Function: end_of_elaboration
   //
   // Called as part of a predefined test flow, this function will check that
   // this component's <req_chan> variable has been configured with a non-null
   // instance of a vmm_channel #(VMM).

   virtual function void end_of_elaboration();
     if (this.req_chan == null)
     `ifdef UVM_ON_TOP
       `uvm_fatal("Connection Error",
          "avt_channel2uvm_tlm requires a request vmm_channel");
      `else
       `vmm_fatal(this.req_chan.log,
          "Connection Error avt_channel2uvm_tlm requires a request vmm_channel");
      `endif
     if (this.rsp_chan != null && this.rsp_is_req)
      `ifdef UVM_ON_TOP
       `uvm_warning("Ignoring rsp_is_req bit",
          "rsp_is_req bit is ignored when a response channel is in use");
       `else
       `vmm_warning(this.rsp_chan.log, "Ignoring rsp_is_req bit rsp_is_req bit is ignored when a response channel is in use");
       `endif
   endfunction


   // Task: run
   //
   // Called as part of a predefined test flow, the run task forks a
   // process for getting requests from the request channel and sending
   // them to the UVM consumer connection via the blocking put port.

   virtual task run();

     // only if port is connected
     if (blocking_put_port.size()) begin
       fork
         auto_put();
       join_none
     end
     else if (blocking_transport_port.size()) begin
       fork
         auto_transport();
       join_none
     end
     else if (blocking_master_port.size()) begin
       fork
         auto_blocking_master();
       join_none
     end

   endtask


   // Function: get_type_name
   //
   // Returns the type name, i.e. "avt_channel2uvm_tlm", of this
   // adapter.

   virtual function string get_type_name();
     return this.type_name;
   endfunction

   const static string type_name = "avt_channel2uvm_tlm";


   // Variable: req_chan
   //
   // Handle to the request vmm_channel #(VMM) instance being adapted. All puts
   // and gets via the TLM exports will be delegated to this channel.

   vmm_channel_typed #(VMM_REQ) req_chan;


   // Variable: rsp_chan
   //
   // Handle to the response vmm_channel #(VMM) instance being adapted. All
   // puts and gets via the TLM exports will be delegated to this channel.

   vmm_channel_typed #(VMM_RSP) rsp_chan;


   // Variable: rsp_is_req
   //
   // Indicates whether a response is the same object as the request with
   // the status and/or read data filled in. When set, and the <rsp_chan> is
   // null, the request process will, after returning from a put to the
   // request channel, copy the VMM request into the orginal UVM request
   // object and send it as the UVM response to the <seq_item_port>'s put
   // method.check
   //
   // In certain vmm_channel/driver
   // completion models, the channel full level is 1 and the connected driver
   // does not consume the transaction until it has been fully executed.
   // In this mode, the driver peeks the transaction from the channel,
   // executes it, fills in the response in fields of the same request
   // object, then finally pops (gets) the transaction off the channel.
   // This then frees the put process, which was waiting for the transaction
   // to leave the the channel. 
   //
   // This variable can be specified in a <new> constructor argument, or set
   // via a set_config_int("rsp_is_req",value) call targeting this component.

   protected bit rsp_is_req = 1;


   int pound_zero_count = 4;

   local VMM_REQ vmm_req[$];

   local UVM_REQ uvm_req[$];


   local bit item_done_on_get = 1;


   // Variable: max_pending_requests
   //
   // Specifies the maximum number of requests that can be outstanding.
   // The adapter holds all outgoing requests in a queue for later
   // matching with incoming responses. A maximum exists to prevent
   // this queue from growing too large.
   //
   // TODO: implement a user-settable timeout for all transactions
   // held in the pending queue.
   int unsigned max_pending_req = 100;


   // Task: auto_put
   //
   // Used by this adapter to send transactions to passive UVM consumers.

   virtual task auto_put();
     UVM_REQ o_req;
     forever begin
       this.peek(o_req);
       this.blocking_put_port.put(o_req);
       this.item_done();
     end
   endtask


   // Task: auto_transport
   //
   // Used by this adapter to send transactions to passive UVM consumers.

   virtual task auto_transport();
     UVM_REQ o_req;
     UVM_RSP o_rsp;
     forever begin
       this.peek(o_req);
       this.blocking_transport_port.transport(o_req,o_rsp);
       this.item_done(o_rsp);
     end
   endtask


   // Task: auto_blocking_master
   //
   // Used by this adapter to send transactions to passive UVM consumers.

   virtual task auto_blocking_master();
     UVM_REQ o_req;
     UVM_RSP o_rsp;
     fork
       // requests
       forever begin
         this.peek(o_req);
         this.blocking_master_port.put(o_req);
         this.item_done_on_get = 0;
         this.item_done();
       end
       // responses
       forever begin
         this.blocking_master_port.get(o_rsp);
         this.item_done(o_rsp);
       end
     join_none
   endtask


   // Function- convert
   //
   //
   function void convert (VMM_REQ v_req, output UVM_REQ o_req);
     if (vmm_req[$] == v_req) begin
       // needed only if req data can change between successive calls to peek
       // t = VMM2UVM_REQ::convert(v_req,uvm_req[$]);
       o_req = uvm_req[$];
     end
     else begin
       if (vmm_req.size() >= max_pending_req) begin
         `ifdef UVM_ON_TOP
          `uvm_fatal("Pending Transactions",
                  $psprintf("Exceeded maximum number of %0d pending requests.",
                     max_pending_req));
         `else
         `vmm_fatal(this.req_chan.log, 
                  $psprintf("Pending Transactions","Exceeded maximum number of %0d pending requests.",
                     max_pending_req));
         `endif
         o_req = null;
         return;
       end
       o_req = VMM2UVM_REQ::convert(v_req);
       uvm_req.push_back(o_req);
       vmm_req.push_back(v_req);
     end
   endfunction



   // Task: get
   //
   // Gets and converts a request from the <req_chan> vmm_channel.

   virtual task get(output UVM_REQ o_req);
     vmm_data v_pop;

     this.peek(o_req);
     if (this.item_done_on_get)
       this.item_done();
     else
       req_chan.XgetX(v_pop);

     this.m_last_o_req = null;
   endtask

   local UVM_REQ m_last_o_req;

   // Function: can_get
   //
   // Returns 1 if a transactions is available to get, 0 otherwise.
   virtual function bit can_get();
     return !(this.req_chan.size() <= this.req_chan.empty_level() ||
              this.req_chan.is_locked(vmm_channel::SINK));
   endfunction
  

   // Function: try_get
   //
   // If a transactions is available to get, returns the transaction
   // in the ~o_req~ output argument, else returns 0.
   virtual function bit try_get(output UVM_REQ o_req);
     vmm_data v_base;
     VMM_REQ v_req;
     if (!can_get())
       return 0;
     this.m_last_o_req = null;
     v_base = req_chan.try_peek();
     assert($cast(v_req, v_base));
     if (this.item_done_on_get)
       this.item_done();
     return 1;
   endfunction



   // Task: peek
   //
   // Peeks (does not consume) and converts a request from the <req_chan>
   // vmm_channel.
   //
   // TO DISCUSS- cached transaction can change between peeks.
   virtual task peek(output UVM_REQ o_req);
     VMM_REQ v_req;
     if (this.m_last_o_req != null) begin
       o_req = m_last_o_req;
       return;
     end
     req_chan.peek(v_req);
     convert(v_req,o_req);
     this.m_last_o_req = o_req;
   endtask


   // Function: can_peek
   //
   // Returns 1 if a transaction is available in the <req_chan>, 0 otherwise.
   //
   virtual function bit can_peek();
     return this.can_get();
   endfunction


   // Function: try_peek
   //
   // If a request is available to peek from the <req_chan>, this function
   // peeks (does not consume) the transaction from the channel, converts,
   // and returns via the ~o_req~ output argument. Otherwise, returns 0.
   //
   // TO DISCUSS- cached transaction can change between peeks.
   virtual function bit try_peek(output UVM_REQ o_req);
     vmm_data v_base;
     VMM_REQ v_req;
     if (!can_peek())
       return 0;
     if (this.m_last_o_req != null) begin
       o_req = m_last_o_req;
       return 1;
     end
     v_base = req_chan.try_peek();
     assert($cast(v_req, v_base));
     convert(v_req,o_req);
     this.m_last_o_req = o_req;
     return 1;
   endfunction


   // Task: put
   //
   // Converts and sneaks a response to the <rsp_chan> vmm_channel, if defined.
   // If the <rsp_chan> is null, the response is dropped.

   virtual task put (UVM_RSP o_rsp);
     put_response(o_rsp);
   endtask

 
   // Function: can_put
   //
   // Always returns 1 (true) because responses are sneaked into the channel.

   virtual function bit can_put ();
     return 1;
   endfunction

 
   // Function: try_put
   //
   // Sneak the given response to the response channel, or copy the
   // response to the corresponding request if <rsp_is_req> is set. 

   virtual function bit try_put (UVM_RSP o_rsp);
     this.put_response(o_rsp);
     return 1;
   endfunction

 
   // Function: write
   //
   // Used by active UVM consumers to send back responses.

   virtual function void write(UVM_RSP o_rsp);
     this.put_response(o_rsp); 
   endfunction


   // seq_item_pull_export implementations

   // Task: get_next_item 
   // 
   // Peeks and converts a request from the <req_chan> vmm_channel. This task
   // behaves like a blocking peek operation; it blocks until an item is
   // available in the channel. When available, the transaction is peeked and
   // ~not consumed from the channel~. The request is consumed upon a call
   // <get> or <item_done>.
   //
   // A call to ~get_next_item~ must always be followed by a call to <get> or
   // <item_done> before calling ~get_next_item~ again.

   virtual task get_next_item(output UVM_REQ t);
     VMM_REQ req;
     req_chan.peek(req);
     if (vmm_req[$] == req) begin
       `ifdef UVM_ON_TOP
       `uvm_error("Trans In-Progress",
         "Get_next_item called twice without item_done or get in between");
       `else
       `vmm_error(this.req_chan.log, "Trans In-Progress  Get_next_item called twice without item_done or get in between");
       `endif
       t = null;
       return;
     end
     this.peek(t);
     this.m_last_o_req = null;
   endtask


  // Task: try_next_item
  //
  // Waits a number of delta cycles waiting for a request
  // transaction to arrive in the <req_chan> vmm_channel. If a request is
  // available after this time, it is peeked from the channel, converted,
  // and returned. If after this time a request is not yet available,
  // the task sets ~t~ to null and returns. This behavior is similar to
  // a blocking peek with a variable delta-cycle timeout.

  virtual task try_next_item (output UVM_REQ t);
    wait_for_sequences();
    if (!has_do_available()) begin
      t = null;
      return;
    end
    get_next_item(t);
  endtask


   // Function: put_response
   //
   // A non-blocking version of <put>, this function converts and sneaks 
   // the given response into the <rsp_chan> vmm_channel. If the <rsp_chan>
   // is null, the response is dropped.

   virtual function void put_response (UVM_RSP o_rsp);

     VMM_REQ v_req;
     VMM_RSP v_rsp;

     if (o_rsp == null) begin
       `ifdef UVM_ON_TOP
       `uvm_fatal("SQRPUT", "Driver put a null response");
       `else
       `vmm_fatal(this.req_chan.log, "SQRPUT Driver put a null response");
       `endif
     end
     else if (o_rsp.get_sequence_id() == -1) begin
       `ifdef UVM_ON_TOP
       `uvm_fatal("SQRPUT",
         "Response has invalid sequence_id");
       `else
       `vmm_fatal(this.req_chan.log, "SQRPUT Response has invalid sequence_id");
       `endif
     end

     // Find the request that corresponds to this response
     foreach (vmm_req[i]) begin
       if (UVM_MATCH_REQ_RSP::match(uvm_req[i], o_rsp)) begin
         v_req = vmm_req[i];
         vmm_req.delete(i);
         uvm_req.delete(i);
         break;
       end
     end

     if (v_req == null) begin
        `ifdef UVM_ON_TOP
        `uvm_error("Orphan Response",
                          "A response did not match a pending request");
        `else
        `vmm_error(this.req_chan.log, "Orphan Response A response did not match a pending request");
        `endif                          
        return;
     end

     // If the response is configured to be the request, the response
     // is provided in the original request transaction.

     if (this.rsp_is_req) begin
        void'(UVM2VMM_RSP::convert(o_rsp, v_req));
        v_req.notify.indicate(vmm_data::ENDED, v_req);
        this.response_ap.write(o_rsp);
        return;
     end

     v_rsp = UVM2VMM_RSP::convert(o_rsp);
     v_req.notify.indicate(vmm_data::ENDED, v_rsp);
     this.response_ap.write(o_rsp);

     // dual channel
     if (this.rsp_chan != null) begin
       this.rsp_chan.sneak(v_rsp);
     end

   endfunction


   // Function: item_done
   //
   // A non-blocking function indicating an UVM driver is done with the
   // transaction retrieved with a <get_next_item> or <get>. The item_done
   // method pops the request off the <req_chan> vmm_channel,
   // converts the response argument, if provided, and sneaks converted response
   // into the <rsp_chan> vmm_channel. If the <rsp_chan> is null and
   // <rsp_is_req> is 0, the response, if provided, is dropped. If <rsp_is_req>
   // is 1, then the response is converted back into the original VMM request
   // and the transaction's ENDED notification is indicated.

   virtual function void item_done(UVM_RSP o_rsp=null);
     VMM_REQ v_req;
     UVM_REQ o_req;
     vmm_data v_req_base;

     // pop off the channel (assumes this hasn't already been done)
     req_chan.XgetX(v_req_base);
     $cast(v_req,v_req_base);

     if (v_req != vmm_req[$]) begin
     `ifdef UVM_ON_TOP
       `uvm_fatal("Item Not Started",
         "Item done called without a previous peek or get_next_item");
     `else
       `vmm_fatal(this.req_chan.log, "Item Not Started Item done called without a previous peek or get_next_item");
     `endif
     return;
     end

     o_req = uvm_req[$];

     this.request_ap.write(o_req);

     if (o_rsp != null) begin
       put_response(o_rsp);
       return;
     end

     if (this.rsp_is_req) begin

       o_req = uvm_req.pop_back();
       v_req = vmm_req.pop_back();

       void'(UVM2VMM_RSP::convert(o_req, v_req));
       v_req.notify.indicate(vmm_data::ENDED, v_req);

       if (this.response_ap.size())
         this.response_ap.write(o_req);
     end

   endfunction

 
   // Function: has_do_available
   //
   // Named for its association with UVM sequencer operation, this function
   // will return 1 if there is a transaction available to get from the
   // vmm_channel, <req_chan>.
 
   virtual function bit has_do_available();
     return !(req_chan.size() == 0 || req_chan.is_locked(vmm_channel::SINK));
   endfunction


   // Task: wait_for_sequences
   //
   // Used in the <try_next_item> method, this method waits a variable number
   // of #0 delays. This give the generator, which may not have resumed from
   // waiting for a previous call to <get> or <item_done>, a chance to wake
   // up and generate and put a new request into the <req_chan>. This allows
   // the driver to execute back-to-back tranasctions and the generator to
   // just-in-time request generation.

   virtual task wait_for_sequences();
     for (int i = 0; i < pound_zero_count; i++) #0;
   endtask



endclass

//------------------------------------------------------------------------------
//    Copyright 2008 Mentor Graphics Corporation
//    All Rights Reserved Worldwide
// 
//    Licensed under the Apache License, Version 2.0 (the "License"); you may
//    not use this file except in compliance with the License.  You may obtain
//    a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
//    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
//    License for the specific language governing permissions and limitations
//    under the License.
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
//
// CLASS: avt_analysis_channel
//
//------------------------------------------------------------------------------
//
// The avt_analysis_channel is used to connect any UVM component with an
// analysis port or export to any VMM component via a vmm_channel.
//
// The adapter operates in two different modes.
//
// UVM analysis port to VMM channel - Connect any UVM component with an analysis
// port to this adapter's <analysis_export>. The adapter will convert all
// incoming UVM transactions to a VMM transaction and ~put~ it to the vmm_channel.
//
// VMM channel to UVM analysis export - Connect the adapter's <analysis_port> to
// one or more UVM components with an analysis export. The adapter will ~get~
// any transaction put into the vmm_channel, convert them to an UVM transaction,
// and broadcast it out the analysis port.
//
// Users should connect either the <analysis_export> or <analysis_port>, not
// both.
//
// (see avt_analysis_channel.gif)
//
// See also the <avt_analysis_channel example>.
//
//------------------------------------------------------------------------------


class avt_analysis_channel #(type UVM=int, VMM=int,
                             UVM2VMM=avt_converter #(UVM,VMM),
                             VMM2UVM=avt_converter #(VMM,UVM))
                         extends uvm_component;

  typedef avt_analysis_channel #(UVM, VMM, UVM2VMM, VMM2UVM) this_type;

  `uvm_component_param_utils(this_type)

  // Port: analysis_export
  //
  // The adapter may receive UVM transactions via this analysis export.
  // The 

  uvm_analysis_imp #(UVM, this_type) analysis_export;


  // Port: analysis_port
  //
  // VMM transactions received from the channel are converted to UVM
  // transactions and broadcast out this analysis port. 

   uvm_analysis_port #(UVM) analysis_port;


  // Function: new
  //
  // Creates a new avt_analysis_channel with the given ~name~ and
  // optional ~parent~; the optional ~chan~ argument provides the
  // handle to the vmm_channel being adapted. If no channel is given,
  // the adapter will create one.

  function new (string name, uvm_component parent=null,
                vmm_channel_typed #(VMM) chan=null);
    super.new(name, parent);
    if (chan == null)
      chan = new("VMM Analysis Channel",name);
    this.chan = chan;
    analysis_export = new("analysis_export",this);
    analysis_port   = new("analysis_port",this);
  endfunction


  // Task: run
  //
  // If the <analysis_port> is connected, the run task
  // will continually get VMM transactions from the vmm_channel and
  // end the converted transactions out the <analysis_port>.

  virtual task run();
    if (analysis_port.size() > 0)
      forever begin
        VMM vmm_t;
        UVM uvm_t;
        chan.get(vmm_t);
        uvm_t = VMM2UVM::convert(vmm_t);
        analysis_port.write(uvm_t);
      end
   endtask


  // Function: write
  //
  // The write method, called via the <analysis_export>, converts
  // an incoming UVM transaction to its VMM counterpart, then sneaks
  // the converted transaction to the vmm_channel.

  function void write(UVM uvm_t);
    VMM vmm_t;
    if (uvm_t == null)
     return;
    vmm_t = UVM2VMM::convert(uvm_t);
    chan.sneak(vmm_t);
  endfunction


   // Variable: chan
   //
   // The vmm_channel instance being adapted; if not supplied in
   // its <new> constructor, the adapter will create one.
   //
   // Incoming transactions from the <analysis_export> will be converted
   // to VMM and ~put~ to this channel.
   //
   // If the <analysis_port> is connected, transaction injected into
   // the channel are fetched, converted, and sent out the <analysis_port>.

   vmm_channel_typed #(VMM) chan;

endclass

//------------------------------------------------------------------------------
//    Copyright 2008 Mentor Graphics Corporation
//    Copyright 2009 Synopsys, Inc.
//    All Rights Reserved Worldwide
// 
//    Licensed under the Apache License, Version 2.0 (the "License"); you may
//    not use this file except in compliance with the License.  You may obtain
//    a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
//    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
//    License for the specific language governing permissions and limitations
//    under the License.
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
//
// CLASS: avt_analysis2notify
//
//------------------------------------------------------------------------------
//
// The avt_analysis2notify adapter receives UVM data from its <analysis_export>,
// converts it to VMM, then indicates the configured event notification,
// passing the converted data as vmm_data-based status. VMM components that have
// registered a callback for the notification will received the converted data
//
// (see avt_analysis2notify.gif)
//
// See also the <avt_analysis2notify example>.
//
//-----------------------------------------------------------------------------

class avt_analysis2notify #(type UVM=int, VMM=int, UVM2VMM=int) extends uvm_component;

  typedef avt_analysis2notify #(UVM,VMM,UVM2VMM) this_type;

  `uvm_component_param_utils(this_type)


  // Port: analysis_export
  //
  // The adapter receives UVM transactions via this analysis export.
  
  uvm_analysis_imp #(UVM,this_type) analysis_export;


  // Variable: notify
  //
  // The notify object that this adapter uses to indicate the <RECEIVED>
  // event notification.

  vmm_notify notify;


  // Variable: RECEIVED
  //
  // The notification id that this adapter indicates upon receipt of
  // UVM data from its <analysis_export>. 

  int RECEIVED;


  // Function: new
  //
  // Creates a new analysis-to-notify adapter with the given ~name~ and
  // optional ~parent~; the ~notify~ and ~notification_id~ together
  // specify the notification event that this adapter will indicate
  // upon receipt of a transaction on its <analysis_export>.
  //
  // If the ~notify~ handle is not supplied or null, the adapter will
  // create one and assign it to the <notify> property. If the 
  // ~notification_id~ is not provided, the adapter will configure a
  // ONE_SHOT notification and assign it to the <RECEIVED> property. 

   //instance of VMM log to capture messages. This is only constructed 
   //if notify is null.
   local vmm_log log;

  function new(string name, uvm_component parent=null,
               vmm_notify notify=null, int notification_id=-1);
    // All instances will be children of uvm_top, so give each a unique name
    super.new(name,parent);
    
    analysis_export = new("analysis_export",this);
    this.notify        = notify;
    if (notify == null) begin
      log              = new("vmm_log","vmm_notify2analysis_adapter_log");
      notify           = new(log);
    end
    if (notification_id == -1)
      notification_id  = notify.configure(-1,vmm_notify::ONE_SHOT);
    else
      if (notify.is_configured(notification_id) != vmm_notify::ONE_SHOT)
        begin
`ifdef UVM_ON_TOP
          uvm_report_fatal("Bad Notification ID",
                           $psprintf({"Notification id %0d not configured, ",
                                      "or not configured as ONE_SHOT"}, 
                                     notification_id));
`endif
`ifdef VMM_ON_TOP
          `vmm_fatal(log,
                     $psprintf({"Notification id %0d not configured, ",
                                "or not configured as ONE_SHOT"}, 
                               notification_id));
`endif
        end
    RECEIVED  = notification_id;
  endfunction


  // Function: write
  //
  // The write method, called via the <analysis_export>, converts
  // an incoming UVM transaction to its VMM counterpart, then indicates
  // the configured <RECEIVE> notification, passing the converted data
  // as status.

  virtual function void write(UVM t);
    VMM vmm_out;
    UVM uvm_in;
    if (t == null)
      return;

    assert($cast(uvm_in,t));
    vmm_out  = UVM2VMM::convert(uvm_in);
    notify.indicate(RECEIVED,vmm_out);
  endfunction

endclass
//------------------------------------------------------------------------------
//    Copyright 2008 Mentor Graphics Corporation
//    All Rights Reserved Worldwide
// 
//    Licensed under the Apache License, Version 2.0 (the "License"); you may
//    not use this file except in compliance with the License.  You may obtain
//    a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
//    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
//    License for the specific language governing permissions and limitations
//    under the License.
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
//
// CLASS- vmm_watcher_cb
//
// Receives data via notification status, then forwards data to the configured
// VMM component. The type of the VMM component is specified in the type
// parameter, and the instance of a VMM component of that type is specified
// in the constructor argument.
// 
//------------------------------------------------------------------------------

class vmm_watcher_cb #(type WATCHER=int) extends vmm_notify_callbacks;

  WATCHER watcher;

  // Function- new
  //
  // Creates a new callback instance that forwards transactions to the
  // object specified in the constructor argument.

  function new (WATCHER watcher);
    this.watcher=watcher;
  endfunction

  // Function- indicated
  //
  // When the notification associated with this callback is indicated, this
  // function is called, which forwards the received data to the target
  // component.

  virtual function void indicated(vmm_data status);
    watcher.indicated(status);
  endfunction

endclass


//------------------------------------------------------------------------------
//
// CLASS: avt_notify2analysis
//
//------------------------------------------------------------------------------
//
// The avt_notify2analysis adapter receives VMM data supplied by a vmm_notify
// event notification, converts it to UVM, then broadcasts it to all components
// connected to its <analysis_port>
//
// (see avt_notify2analysis.gif)
//
// See also <avt_notify2analysis example>.
//
//------------------------------------------------------------------------------

class avt_notify2analysis #(type VMM=int, UVM=int, VMM2UVM=int) 
        extends uvm_component;

  typedef avt_notify2analysis #(VMM,UVM,VMM2UVM) this_type;

  `uvm_component_param_utils(this_type)


  // Port: analysis_port
  //
  // The adapter writes converted VMM data supplied by a vmm_notify event
  // notification to this analysis_port. 
  //
  // Components connected to this analysis port via an analysis export will
  // receive these transactions in a non-blocking fashion. If a receiver can
  // not immediately accept broadcast transactions, it must buffer them.

  uvm_analysis_port #(UVM) analysis_port;


  // Variable: notify
  //
  // The notify object that this adapter uses to register a callback on the
  // <RECEIVED> event notification.

  vmm_notify notify;


  // Variable: RECEIVED
  //
  // The notification id that, when indicated, will provide data to
  // a callback registered by this adapter. The callback will forward
  // the data to the <indicated> method.

  int RECEIVED;


  // Function: new
  //
  // Creates a new notify-to-analysis adapter with the given ~name~ and
  // optional ~parent~; the ~notify~ and ~notification_id~ together
  // specify the notification instance that this adapter will be
  // sensitive to. The adapter will register a callback that is called
  // when the notification is indicated. The callback will forward the
  // (status) transaction to the <indicated> method.   
  //
  // If the ~notify~ handle is not supplied or null, the adapter will
  // create one and assign it to the <notify> property. If the 
  // ~notification_id~ is not provided, the adapter will configure a
  // ONE_SHOT notification and assign it to the <RECEIVED> property. 

  function  new (string name, uvm_component parent=null,
                vmm_notify notify=null, int notification_id=-1);

    vmm_watcher_cb #(this_type) cb;

    super.new(name,parent);

    analysis_port = new("analysis_port",this);

    if (notify == null) begin
      vmm_log log;
      log = new("vmm_log","avt_notify2analysis_log");
      notify = new(log);
    end

    this.notify = notify;

    if (notification_id == -1)
      notification_id = notify.configure(-1,vmm_notify::ONE_SHOT);
    else
      if (notify.is_configured(notification_id) != vmm_notify::ONE_SHOT)
        uvm_report_fatal("Bad Notification ID",
          $psprintf({"Notification id %0d not configured, ",
                    "or not configured as ONE_SHOT"}, notification_id));
    this.RECEIVED = notification_id;

    cb = new(this);
    notify.append_callback(RECEIVED, cb);

  endfunction


  // Function: indicated
  //
  // Called back when the <RECEIVED> notification in the <notify>
  // object is indicated, this method converts the <VMM> data given
  // in the ~status~ argument to its <UVM> counterpart, then send
  // it out the <analysis_port> to any connected subscribers.

  virtual function void indicated(vmm_data status);
    UVM uvm_out;
    VMM vmm_in;
    if (status == null)
      return;
    assert ($cast(vmm_in,status));
    uvm_out = VMM2UVM::convert(vmm_in);
    analysis_port.write(uvm_out);
  endfunction

endclass



endpackage // avt_interop_pkg
  
import avt_interop_pkg::*;

`endif // UVM_VMM_PKG_SV
